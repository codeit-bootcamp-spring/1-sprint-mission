
직접 참조, 간접 참조에 대해서 공부

방어적 복사, 깊은 복사, 얕은 복사

객체지향은 직접참조가 더 좋다.
객체지향은 .  으로 참조를 한 줄에 한 번이 좋음
 -equals 랑 해시태그를 무조건 재정의하라
 리무브를 하더라도 안될 수 있다. 같은 거로 안 볼 수도 있으니 == 이거 링크로 나중에 주심

 Q. 리스트가 아니라 맵을 써도 되느냐
 A. 순회하는 코드들 맵을 쓰면 성능의 이점을 누릴 수 있다.
 optional로 감쌌으니 getordefault라는 함수를 사용하여 return.
 이렇게 순회를 하면 기본이 bigo가 n. getor는 1이다.

TDD
테스트 코드를 짜야한다.
매번 결과물을 돌려야하는데
이걸 테스트 코드를 짜면 육안으로 확인하는 부분이 자동화가  됨.
의존성이 있는 update채널을 했을때 진짜로 업데이트가 되는지 눈으로 직접 확인해 보는 코드를 뜻함.
디버그를 많이 활용할 것
한 줄 한 줄 확인 하는 거 좋음

내가 할 일
직접 참조 코드 하나랑
깊은 복사 코드 하나 제작
출력 시간 예쁘게 변경
향상된 for문을 iterator를 사용해서 리무브 할 수 있도록 변경 테스트 해보기
테스트 코드 짜보기.

토요일까지 예쁘게 다듬어서 pr하고 일요일까지 예쁘게 다듬기.
테스트 코드 assertj나 junit5로 테스트 코드를 해볼 수 있음.
테스트코드를 작성할 줄 알아야 함.

TDD = 업데이트 채널이 없다고 가정하고, 새로 만든다고 가정하면
- 태스트코드를 먼저 실행해본다.
장점: 유저가 메세지를 알아도 괜찮은데 암튼 객체지향..? 모르겠네
테스트 코드를 먼저 짜서.. 눈으로 확인을 먼저 하고 사용하면 좋다..?
객체가 옳바른 책임을 다하는지 확인할 수 있고
코드가 깔끔해짐!


UUID 로 전부 다 ..? 아님 유저가 통째로 들어가는?
클래스를 온전히 다 가져오는??
작어도 이 미션에 한해서는 메세지가 유저를 알고 있는게 매우 효율적이기 때문에
다만 실무에서는 직접 참조를 하는 경우가 적고 보통 아이디를 들고 있는다.
db의 세계에서는 메세지 테이블에서 유저라는 것을 들고 있을 수 없다.
보통 long 타입의 아이디를 가지고 있다.

채널안에 메세지, 메세지 안에 채널
메세지 안에 채널 아이디를 가지는 것이 좋다.


디비 관점에서는 채널안에 메세지 아이디를 갖는 것이 좋음

다만 객체 관점에서는 메세지(많은 쪽)이 채널을 알고있는 것이 편하다.

이게 어려운 질문 두개가 의존하기 때문에 영속성을 생각해야해서 둘 중에 뭘 선택할지 고민하는 것.

너무 간결해지면 전부 다 의존하게 됨.
결국 하나의 객체가 됨.
그러면 사실,, 책임이 되게 모호해짐 의존성을 끊어내는 것도 필요함 (책임을 위해서)
