### 파일 업로드 multipart/form-data

파일 업로드를 한다면, @RequestPart 어노테이션을 일반적으로 사용한다고 합니다.
(0) 제공된 script.js의 변수명 내 변수 이름과 동일하게 변경 -> (1) User Controller의 createUser 수정 -> (2)Postman 설정
순서로 진행했습니다.

(1) consumes를 통해 mediaType을 지정하고, 각 파라미터 메서드의 어노테이션을 @RequestPart 로 변경했다.

    @RequestMapping(method = RequestMethod.POST, consumes = {MediaType.MULTIPART_FORM_DATA_VALUE})
    public ResponseEntity<UserCreateResponse> createUser(
            @RequestPart(value = "userCreateRequest") UserCreateRequest userCreateRequest,
            // multipart/form-data 형식으로 요청보낼 때 파일의 키 이름을 "binaryContent"
            @RequestPart(value = "binaryContent", required = false) MultipartFile file) throws Exception {

        BinaryContentCreateRequest binaryContentCreateRequest;
        if(file != null){
            binaryContentCreateRequest = new BinaryContentCreateRequest(file);
        }else {
            binaryContentCreateRequest = null;
        }

        UserCreateResponse userCreateResponse = userService.createUser(userCreateRequest, binaryContentCreateRequest);
        // .ok 응답코드 200 + body
        return ResponseEntity.ok(userCreateResponse);
    }

(2) Postman에서 Working directory 연결, Body를 form-data로 전송

[Postman에서 Content-type을 명시하자
](https://velog.io/@songunnie/Spring-Resolved-org.springframework.web.HttpMediaTypeNotSupportedException-Content-type-applicationoctet-stream-not-supported-%EC%97%90%EB%9F%AC-%ED%95%B4%EA%B2%B0%ED%95%98%EA%B8%B0
)

![img_2.png](img_2.png)
잘 전달되고 있다!

### script.js의 fetchUserProfile

    async function fetchUserProfile(profileId) {
    try {
    // const response = await fetch(`${ENDPOINTS.BINARY_CONTENT}?binaryContentId=${id}`);
    const response = await fetch(`${ENDPOINTS.BINARY_CONTENT}/${profileId}`);
    if (!response.ok) throw new Error('Failed to fetch profile');
    const profile = await response.json();
    
            // Convert base64 encoded bytes to data URL
            return `data:${profile.contentType};base64,${profile.bytes}`;
        } catch (error) {
            console.error('Error fetching profile:', error);
            return '/default-avatar.png'; // Fallback to default avatar
        }
    }

default 이미지의 경우 등록이 되는데,
Postman에서 전송하는 이미지 자체가 "없는 것"으로 판단되어, 항상 default 이미지만 등록되는 문제가 있었다.

    // Get profile image URL
    const profileUrl = user.profileId ?

자바스크립트 내의 코드상에 작성된 코드를 보고 유저에게서 Id를 가져온다고 생각해서,
"Entity에 직접 접근"이라고 생각했었다.

그러나 `USERS: ${API_BASE_URL}/users` 이고,
`const response = await fetch(ENDPOINTS.USERS)`에서 `fetch()` 함수의 기본 HTTP 메서드 `GET`을 이용하는 거고,
생각해보니 HTTP 메서드 `GET`으로 `/api/users` 엔드포인트로 접근하면...

    @RequestMapping(method = RequestMethod.GET)
    public ResponseEntity<Collection<UserFindResponse>> findAllUsers(){
        return ResponseEntity.ok(userService.showAllUsers());
    }

UserFindResponse DTO 를 응답받을 수 있었다.
**예전에 고의적으로 UserFindResponse DTO에서 profileId는 빼놨었다.** 해당 DTO를 만들 당시에는 정적 사이트를 서빙하는 조건이 없었기에
필요가 없을 거라 생각했었던 것 같다.
때문에 profileId를 UserFindResponse 에 포함시켰고, Id 전달을 위해 관련 추가적으로 작업했다.

### (1) user-list.html 화면과 콘솔

![img_3.png](img_3.png)

미동도 없던 것이 움직이기 시작했다.
이 문제를 해결하기 위해, users-list.html 페이지의 개발자 도구를 켜서 사용자 프로필 이미지가 어떤 주소로 매핑되어 있는지 확인했다.
`data:${profile.contentType};base64,${profile.bytes}` _* script.js fetchUserProfile 메서드가 반환하는 주소 값_

#### 이 뒤부터는 error-log, 파일 업로드하기에 작성돼 있습니다.