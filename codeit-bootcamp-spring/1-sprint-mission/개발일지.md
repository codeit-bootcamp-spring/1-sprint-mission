# 개발 일지

요구사항을 만족하면서 어떤 기능을 왜 사용했는지, 사용하지 않았는지 결정하는데 트레이드 오프에 대한 생각을 정리

## 유저 기능 개발 고민
### 생성자에 빌더 기능
자주 사용하는 롬복의 기능인 빌더를 사용할까 고민했다. 

빌더 패턴을 도입 시에 얻을 수 있는 장점으로는 생성자의 파라미터로 들어오는 매개변수의 가독성을 높일 수 있다.   
하지만, 롬복의 기능이 제공하는 기능이 없이 직접 구현하려다 보니, 개발 초기 도메인에 필요한 인스턴스 필드의 
변경 가능성이 높아 구현에 너무 오래걸리는 단점이 존재했다. 이에 아직 많은 필드를 초기화하지 않기에 빌더 패턴을 
사용하지 않기로 결정했다.

### User 객체에서 UserName 객체를 분리   
User 객체에서 String으로 유저의 이름을 저장하고 있었는데, 검증로직과 테스트 코드 작성 시 복잡함을 해소할 수 있어,
분리하게 되었다.


## Repository 추상화 
스프링부트 처럼 crud의 일정 부분의 구현은 모두 같을텐데, 이에 대해서 고민을 하게 되었다. 부트에서는 어떤 방식으로 레포지터리를 구현했는지 찾아본 후 구현

# 테스트 코드
## 테스트 코드에서 인터페이스 필드 초기화
- DI
- Factory Method
- Mock 객체 
## 테스트 케이스 작성 시 service에서 repository 의존성 문제
### UserService 테스트 코드 작성
테스트 코드 작성에 앞서 테스트 코드는 `FIRST` 원칙을 지켜야하는데, `UserService`에서 의존하는 `UserRepository` 객체의 구현체를 넣어줄 경우 원칙에서 어긋난다.  
이를 해결하는 방법으로 Mock 객체를 통해서 결합을 없애고 테스트 작성해야한다. 내가 아는 방법으로는 일단 Mock 객체를 이용해서 해결하면되는 것으로 아는데, 이참에 학습
을 통해서 적용해봐야겠다.

또 다른 방법이 있나? 
- 스모크 테스트
- mock 객체를 미리 만드는 방법 ?
# error
- error 상속받아 사용할 때, 매개변수로 들어가는 `Throwable` 넣어주었을 때 결과는 ?
- 그냥 다 illegalArgumentException, IllegalStatementException 으로 처리하고 싶은데... 
## enum - error message
- message 하드 코딩?
- 상수 값으로 해두고 사용 ?

# 정적 팩토리 

## spy 객체

## 객체의 상태를 업데이트할 때 고려할 점
객체를 찾아오는 findByXXX 메서드는 Optional로 값을 반환하는데, 값이 없을 경우에 throw 해야하는가 ? 해야한다면 메서드 명을 throw를 달아주어야 하는가?

## Database의 역할을 하는 곳의 자료 구조 추가 하는 것의 대한 고찰
- 지금은 Id(UUID) 값으로만 hash값으로 key를 가지고 있다.
- 추가적인 자료구조로 name(String)을 hash값으로 key를 가지고 있는 자료구조를 추가하고 싶다.
사용자가 id 이외에도 name 값으로 데이터를 찾게 해서 기능을 조금 더 확장하고 싶고, 이름으로 찾을 때 O(1) 로 데이터를 찾고 싶다. 그리고 
이름이 중복되지 않도록 할 수 있다. 하지만, 데이터 정합성을 위해서 코딩을 잘해주어야 한다.

학습 - 자료구조 BigO 학습

## 팩토리 패턴으로 의존성을 주입해야 한다. 
아직 어떻게 구현해야하는지 잘 모름. 학습이 필요함. 어디서부터 ? 일단 팩토리 패턴부터. 


## 모든 파라미터로 들어오는 값을 null 체크를 해주어야 하는가 ?



## 파라미터로 넘어온 참조에 의한 값 전달
파라미터에 값이 재할당이 되지 않도록 명시적으로 표현하기 위해 `final` 키워드를 붙여주는 것에 대해서 고민.

`Java` 는 참조에 의한 값 전달 (**callByValue**) 방식을 사용한다. `Java`에는 `C` 언어처럼 포인터라는 개념을 사용하지 않는다.
`*` 를 이용해서 reference address 를 접근하는 것과 다르다. 

자바에서 객체를 참조주소로 값을 식별하는게 아닌가? 그러니까 참조 주소를 값으로 호출하는 것이 아닌가에 대한 모호함

중요한건 파라미터에 `final` 키워드를 붙여야 하는가에 대한 것이다. 값 재할당을 불가능 하도록 명시적으로 해주었는데 코드를 읽는데 가독성을 해치는 것 같다.

### Java call-by-value
- `Java`에서는 모든 메서드 호출이 값에 의한 호출 방식으로 이루어진다.
- 객체를 메서드에 전달할 때, 객체의 **참조값(Reference Address)** 이 복사되어 전달된다.
- 중요한 점은 **참조값 자체도 하나의 값**으로 처리된다는 것이다.
```java
Dog myDog = new Dog("alex");

void foo(Dog dog) {
    dog = new Dog("flex");
}

foo(myDog);
// myDog = "alex"
```
`foo` 메서드 호출 시, `myDog` 객체의 참조값이 복사되어 `dog` 매개변수로 전달된다. 그래서 메서드의 매개변수 dog에 새로운 참조값을 할당하는 것이지, `myDog`에 영향을 주는 것이 아니다.

따라서 메서드가 종료된 후, 원래의 `myDog`는 여전히 `Dog("alex") 객체를 참조한다.

### Java의 참조와 C 언어의 포인터의 차이
모호했던 부분을 정리하면 `Java`에는 포인터라는 개념이 없고, 객체는 **참조값**을 통해 관리되고, `C` 에서 포인터는 메모리 주소를 직접 다루고 `*`을 이용해 직접 접근한다는 것이다.
- `C`에서 포인터는 메모리 주소를 직접 다루고 `*`를 통해 값을 변경할 수 있다.

```
void foo(int* x) {
    *x = 20;
}
int main() {
    int a = 10;
    foo(&a); // 주소 전달
    printf("%d", a); // 20
}
```
정리하면, `C`에서는 `*`로 메모리 값을 직접 변경할 수 있지만, `Java`에서는 객체의 참조값을 조작하지 않는다.
- `Java`에서는 객체의 참조값이 복사되어 전달되므로, 참조값 자체를 재할당해도 호출한 곳에는 영향을 주지 않는다.

### `final` 키워드을 사용하지 않게된 이유
메서드 파라미터로 넘어온 객체의 참조값은 복사된 것으로 호출한 곳의 객체에 영향을 주지 않는다. 그렇기에 `final` 키워드를 사용하지않고도
`Java`의 특성상 재할당되지 않는다. `final`을 붙일 경우 명시적으로 표현할 수 있고, 재할당할 경우 컴파일 단계에서 에러를 확인할 수 있지만,
코드의 간결성과 가독성을 해칠 수 있기에 나는 사용하지 않기로 했다.

[참조 사이트](https://softwareengineering.stackexchange.com/questions/48413/in-java-should-i-use-final-for-parameters-and-locals-even-when-i-dont-have-t)